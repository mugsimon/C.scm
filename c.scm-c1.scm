;;; tutのオリジナルのc1を実行する
;;; c0を適用済みと想定
;;; 省略記法のdefine式, ローカルdefine, cond, case, do, 関数位置のlambda, quasiquote, unquote, unquote-splicingはないと想定
;;; c2~の部分を変更
;;; ローカル変数はmake-varによるリストになる
;;; 

;; マクロ
(define-syntax dlet
  (syntax-rules ()
    ((dlet ((var val) ...) body ...)
     (let ((stack (list var ...)))
       (define (pop)
         (let ((top (car stack)))
           (set! stack (cdr stack))
           top))
       (set! var val) ...
       (let ((retval (begin body ...)))
         (set! var (pop)) ...
         retval)))))

(define-syntax dolist
  (syntax-rules ()
    ((dolist (var lst) body ...)
     (let loop ((rest lst))
       (cond ((null? rest)
              '())
             (else
              (let ((var (car rest)))
                (begin body ...)
                (loop (cdr rest)))))))))

(define c.scm:*c1cont* #f)

;; (define var (lambda params body))
;; (define var expr)
;; (begin ...)
;; (fun ...)
(define (c.scm:c1 x)
  (call/cc
   (lambda (cont)
     (set! c.scm:*c1cont* cont)
     (if (pair? x)
         (case (car x)
           ((define)
            (let ((form (caddr x)))
              (if (and (pair? form)
                       (eq? (car form) 'lambda))
                  (c.scm:c1compile-function (car x) ;; define
                                            (cons (cadr x) (cadr form)) ;; (var params), (var . param)
                                            (cddr form))
                  `(,(car x) ,(cadr x) ,(c.scm:c1compile-expr form)))))
           ((begin)
            `(begin ,@(map c.scm:c1 (cdr x))))
           (else
            (c.scm:c1compile-expr x)))
         (c.scm:c1compile-expr x)))))

;; first->define
;; args->(var params)|(var . param)
;; body->expr
(define (c.scm:c1compile-function first args body)
  (let ((x (dlet ((*env* '()))
                 (c1lam (cons (cdr args) body)))))
    `(,first ,(car args) (lambda ,@x))))

;; form->expr
(define (c.scm:c1compile-expr form)
  (let ((x (dlet ((*env* '()))
                 (c1expr form))))
    x))

;; 自己評価的データなら#tを返す
;; x->expr
(define (c.scm:self-eval? x)
  (or (boolean? x)
      (number? x)
      (char? x)
      (string? x)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SCTOPS  Compiler toplevel.

(define *bc-code* '())
(define *bc-codep* '())

(define *local-funs* '())
(define *cclosures* '())

(define *inline-functions* #f)

(define set-fun-data '())            ;;;;; By A243  Dec, 1992 ;;;;;

(define (compile-file x)
  (let* ((fname (if (symbol? x) (symbol->string x) x))
         (out (open-output-file (string-append fname ".fas")))
         (in (open-input-file (string-append fname ".lsp"))))
    (do ((form (read in) (read in)))
        ((eof-object? form))
        (write-code (compile form) out)
        ;(write (compile form) out)
        ;(write (compile form))
        )
    (close-input-port in)
    (close-output-port out)))

(define (write-code code out)
  (case (car code)
    ((DEFINE)
     (case (car (caddr code))
       ((COMPILED-FUNCTION)
;        (format out "~&(DEFINE ~s (COMPILED-FUNCTION '~s ~d '(~%"
        (format out "~&(DEFINE ~s (COMPILED-FUNCTION ~s ~d '(~%"
          (cadr code) (cadr (caddr code)) (caddr (caddr code)))
        (write-code-body (cadr (cadddr (caddr code))) out)
        (format out ")))"))
       ((LOAD-TIME-EVAL)
        (format out "~&(DEFINE ~s (LOAD-TIME-EVAL '(~%" (cadr code))
        (write-code-body (cadr (cadr (caddr code))) out)
        (format out ")))"))))
    ((MACRO)
;     (format out "~&(MACRO ~s (COMPILED-FUNCTION '~s ~d '(~%"
     (format out "~&(MACRO ~s (COMPILED-FUNCTION ~s ~d '(~%"
       (cadr code) (cadr (caddr code)) (caddr (caddr code)))
     (write-code-body (cadr (cadddr (caddr code))) out)
     (format out ")))"))
    ((LOAD-TIME-EVAL)
     (format out "~&(LOAD-TIME-EVAL '(~%")
     (write-code-body (cadr (cadr code)) out)
     (format out "))"))
    ((BEGIN)
     (format out "~&(BEGIN~%")
     (write-code-body (cdr code) out)
     (format out ")"))))

#|
(define (write-code-body body out)
  (do ((x body (cdr x)))
      ((null? x))
    (if (symbol? (car x))
        (format out "~&  ~s" (car x))
        (format out "	~s~%" (car x)))))
|#

(define (write-code-body body out)
  (do ((x body (cdr x)))
      ((null? x))
    (if (symbol? (car x))
        (format out "~&  ~s" (car x))
        (if (eq? (caar x) 'LOCAL-FUNCTION)
            (begin
              (format out "~&  (LOCAL-FUNCTION~%")
              (write-code-body (cdar x) out)
              (format out "  )~%"))
            (format out "	~s~%" (car x))))))

(define (compile x)
  (if (pair? x)
      (case (car x)
        ((define macro)
         (if (symbol? (cadr x))
             (let ((form (macroexpand (caddr x))))
               (if (and (pair? form) (eq? (car form) 'lambda))
                   (compile-function (car x)
                                     (cons (cadr x) (cadr form))
                                     (cddr form))
                   `(,(car x) ,(cadr x) ,(compile-expr form))))
             (compile-function (car x) (cadr x) (cddr x))))
        ((begin) (cons 'BEGIN (map compile (cdr x))))
        (else (if (and (symbol? (car x)) (macro-function (car x)))
                  (compile ((macro-function (car x)) x))
                  (compile-expr x))))
      (compile-expr x)))

(define (compile-expr form)
  (wt-begin)
  (let ((x (dlet ((*env* '())) (c1expr form))))
    (dlet ((*local-funs* '()) (*cclosures* '())
           (*level* 0) (*sp* -1) (*bp* 0) (*last-label* 0)
           (*cenv-length* 0) (*cenv-loc* '()) (*clink* '()) (*ccb-vs* 0)
           (*value-to-go* 'BX) (*exit* 'XRETURN))
      (c2expr x)
      (do () ((and (null? *cclosures*) (null? *local-funs*)))
          (if (not (null? *cclosures*))
              (let ((y (car *cclosures*)))
                (set! *cclosures* (cdr *cclosures*))
                ;; for DOS
                ;(apply c2cclosure y)
                ;; for UNIX
                (apply (car y) (cdr y))
                ;;
                ))
          (if (not (null? *local-funs*))
              (let ((y (car *local-funs*)))
                (set! *local-funs* (cdr *local-funs*))
                (apply c2local-fun y))))))
     (wt-end-expr))

(define (compile-function first args body)
  (if (not (and (pair? args) (symbol? (car args))))
      (scerror "~s is a bad arg to DEFINE." args))
  (wt-begin)
  (let ((x (dlet ((*env* '())) (c1lam (cons (cdr args) body)))))
    (dlet ((*local-funs* '()) (*cclosures* '())
           (*level* 0) (*sp* -1) (*bp* 0) (*last-label* 0))
      (apply c2lam (next-label2) x)
      (do () ((and (null? *cclosures*) (null? *local-funs*)))
          (if (not (null? *cclosures*))
              (let ((y (car *cclosures*)))
                (set! *cclosures* (cdr *cclosures*))
                ;; for DOS
                ;(apply c2cclosure y)
                ;; for UNIX
                (apply (car y) (cdr y))
                ;;
                ))
          (if (not (null? *local-funs*))
              (let ((y (car *local-funs*)))
                (set! *local-funs* (cdr *local-funs*))
                (apply c2local-fun y))))))
     (wt-end-function first (car args) args))

(define (macroexpand form)
  (if (and (pair? form) (symbol? (car form)) (macro-function (car form)))
      (macroexpand ((macro-function (car form)) form))
      form))

;;; Intrinsic constants

(define (c1constant x)
  #;(list c2constant x)
  (if (c.scm:self-eval? x)
      x
      `(quote ,x)))

(define (c2constant x)
  (case *value-to-go*
    ((BX) (wt `(get-const ,x)))
    ((PUSH) (wt `(push-const ,x))))
  (cmp:exit))

(define c1null #;(list c2constant '())
  `'())
(define c1false #;(list c2constant #f)
  #f)
(define c1true #;(list c2constant #t)
  #t)
(define c1if-else-default #;(list c2constant '())
  `'())
(define c1cond-else-default #;(list c2constant '())
  `'())
(define c1begin-empty-default #;(list c2constant '())
  `'())

;;; SCBIND  Variable Binding.

(define *sp* 0)
(define *bp* 0)

(define *clink* '())
(define *ccb-vs* 0)
(define *cenv-length* 0)
(define *cenv-loc* '())
(define *level* 0)

(define (c2lambda-bind var)
  (set! *sp* (- *sp* 1))
  (c2bind var))

(define (c2bind var)
  (set-var-loc var (cons *level* *sp*))
  (cond ((var-closed var)
         (set-var-closed var *ccb-vs*)
         (set! *ccb-vs* (+ *ccb-vs* 1))
         (cond ((null? *clink*) (wt `(lift-nil ,(- *sp* *bp*))))
               ((= (car *clink*) *level*)
                (wt `(lift0 ,(- *sp* *bp*) ,(- (cdr *clink*) *bp*))))
               (else (wt `(lift ,(- *sp* *bp*) ,*bp*
                                ,(- *level* (car *clink*)) ,(cdr *clink*)))))
         (set! *clink* (var-loc var)))
        ((var-assigned var) (wt `(lift-nil ,(- *sp* *bp*))))))

;;; SCCOND  Conditionals.

(define (c1if args)
  (if (or (end? args) (end? (cdr args))
	  (and (not (end? (cddr args)))
	       (not (end? (cdddr args)))))
      (scbad-args 'if args))
  (list 'if #;c2if
        (c1fmla (car args))
        (c1expr (cadr args))
        (if (null? (cddr args)) c1if-else-default (c1expr (caddr args)))))

(define (c1fmla fmla)
  (if (pair? fmla)
      (case (car fmla)
        ((and #;AND) (cond
                 ((end? (cdr fmla)) c1true)
                 ((end? (cddr fmla)) (c1fmla (cadr fmla)))
                 (else (cons 'and #;'FMLA-AND (c1map c1fmla (cdr fmla))))))
        ((or #;OR) (cond
                ((end? (cdr fmla)) c1false)
                ((end? (cddr fmla)) (c1fmla (cadr fmla)))
                (else (cons 'or #;'FMLA-OR (c1map c1fmla (cdr fmla))))))
        ((not #;NOT) (cond ((c1lookup 'not) (c1expr fmla))
                     ((or (end? (cdr fmla)) (not (end? (cddr fmla))))
                      (scbad-args 'not (cdr fmla)))
                     (else (list 'not #;'FMLA-NOT (c1fmla (cadr fmla))))))
        (else (c1expr fmla)))
      (c1expr fmla)))

(define (c2if fmla form1 form2)
  (if (and (eq? (car form2) c2constant)
           (eq? *value-to-go* 'TRASH)
           (member *exit* '(NEXT ESCAPE)))
      (let ((Tlabel (next-label)) (Flabel *exit-label*))
        (dlet ((*exit* 'NEXT) (*exit-label* Tlabel)) (CJF fmla Flabel))
        (wt-label Tlabel)
        (c2expr form1))
      (let ((Tlabel (next-label)) (Flabel (next-label)))
        (dlet ((*exit* 'NEXT) (*exit-label* Tlabel)) (CJF fmla Flabel))
        (wt-label Tlabel)
        (case *exit*
          ((NEXT) (dlet ((*exit* 'ESCAPE)) (c2expr form1)))
          ((UNWIND-NEXT) (dlet ((*exit* 'UNWIND-ESCAPE)) (c2expr form1)))
          (else (c2expr form1)))
        (wt-label Flabel)
        (c2expr form2))))

(define (CJT fmla Tlabel)
  (case (car fmla)
    ((FMLA-AND) (do ((fs (cdr fmla) (cdr fs)))
                    ((null? (cdr fs)) (CJT (car fs) Tlabel))
                  (let ((Flabel *exit-label*))
                    (dlet ((*exit-label* (next-label)))
                      (CJF (car fs) Flabel)
                      (wt-label *exit-label*)))))
    ((FMLA-OR) (do ((fs (cdr fmla) (cdr fs)))
                   ((null? (cdr fs)) (CJT (car fs) Tlabel))
                 (dlet ((*exit-label* (next-label)))
                   (CJT (car fs) Tlabel)
                   (wt-label *exit-label*))))
    ((FMLA-NOT) (CJF (cadr fmla) Tlabel))
    (else (c2get-expr* fmla)
          (wt `(jmp-if-true ,(touch-label Tlabel))))))

(define (CJF fmla Flabel)
  (case (car fmla)
    ((FMLA-AND) (do ((fs (cdr fmla) (cdr fs)))
                    ((null? (cdr fs)) (CJF (car fs) Flabel))
                  (dlet ((*exit-label* (next-label)))
                    (CJF (car fs) Flabel)
                    (wt-label *exit-label*))))
    ((FMLA-OR) (do ((fs (cdr fmla) (cdr fs)))
                   ((null? (cdr fs)) (CJF (car fs) Flabel))
                 (let ((Tlabel *exit-label*))
                   (dlet ((*exit-label* (next-label)))
                     (CJT (car fs) Tlabel)
                     (wt-label *exit-label*)))))
    ((FMLA-NOT) (CJT (cadr fmla) Flabel))
    (else (c2get-expr* fmla)
          (wt `(jmp-if-false ,(touch-label Flabel))))))

(define (c1and args)
  (cond ((end? args) c1true)
        ((end? (cdr args)) (c1expr (car args)))
        (else (list 'and #;c2and (c1args args)))))

(define (c1or args)
  (cond ((end? args) c1false)
        ((end? (cdr args)) (c1expr (car args)))
        (else (list 'or #;c2or (c1args args)))))

(define (c2and forms)
  (do ((forms forms (cdr forms)))
      ((null? (cdr forms))
       (c2expr (car forms)))
    (c2get-expr* (car forms))
    (let ((label (next-label2)))
      (wt `(jmp-if-true ,(touch-label label)))
      (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
      (exit-always)
      (wt-label label))))

(define (c2or forms)
  (dlet ((*sp* *sp*))
    (do ((forms forms (cdr forms)))
        ((null? (cdr forms))
         (c2expr (car forms)))
      (c2get-expr* (car forms))
      (let ((label (next-label2)))
        (wt `(jmp-if-false ,(touch-label label)))
        (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
        (exit-always)
        (wt-label label)))))

(define (c1cond args)
  (c1expr (c1expand-cond args)))

(define (c1expand-cond args)
  (if (null? args)
      (cadr c1cond-else-default)
      (let ((clause (car args)) (rest (cdr args)))
        (cond ((end? clause) (scbad-args 'cond clause))
              ((eq? (car clause) 'else)
               `(begin ,@(cdr clause)))
              ((end? (cdr clause))
               (if (end? rest)
                   (car clause)
                   `(or ,(car clause) ,(c1expand-cond rest))))
              ((and (eq? (cadr clause) '=>)
                    (not (end? (cddr clause)))
                    (end? (cdddr clause)))
               (let ((temp (gensym)))
                 `(let ((,temp ,(car clause)))
                    (if ,temp
                        (,(caddr clause) ,temp)
                        ,(c1expand-cond rest)))))
              (else `(if ,(car clause)
                         (begin ,@(cdr clause))
                         ,(c1expand-cond rest)))))))

(define (c1case args)
  (cond ((end? args) (scbad-args 'case args))
        ((end? (cdr args))
         (c1begin (list (car args) (cadr c1cond-else-default))))
        (else
          (let ((temp (gensym)))
            (c1expr `(let ((,temp ,(car args)))
                       ,(c1expand-case temp (cdr args))))))))

(define (c1expand-case key clauses)
  (if (end? clauses)
      (cadr c1cond-else-default)
      (let ((clause (car clauses)) (rest (cdr clauses)))
        (cond ((end? clause) (scbad-args 'case clause))
              ((eq? (car clause) 'else)
               `(begin ,@(cdr clause)))
              ((null? (car clause))
               (c1expand-case key rest))
              (else `(if (or ,@(c1map (lambda (sym) `(eqv? ,key ',sym))
                                      (car clause)))
                         (begin ,@(cdr clause))
                         ,(c1expand-case key rest)))))))

;;; SCEVAL  The Expression Dispatcher.

(define (c1expr form)
  (cond ((symbol? form)
         (c1vref form))
        ((pair? form)
         (let ((fun (car form)) (args (cdr form)))
           (cond ((symbol? fun)
                  (case fun
                    ((if) (c1if args)) 
                    ((cond) (c1cond args))
                    ((case) (c1case args))
                    ((and) (c1and args))
                    ((or) (c1or args))
                    ((begin) (c1begin args))
                    ((lambda) (c1lambda args))
                    ((delay) (c1delay args))
                    ((let) (c1let args))
                    ((let*) (c1let* args))
                    ((letrec) (c1letrec args))
                    ((do) (c1do args))
                    ((set!) (c1set! args))
                    ((quote) (c1quote args))
                    ((quasiquote) (c1quasiquote args))
                    ((define) (c1define args))
                    ((macro) (c1macro args))
                    (else
                     (c1symbol-fun fun args) ;; c.scm:c1
                     #;(if (>= *re-compile-level* 2)
                            (set-fun-data fun)) ;;;;; By A243  Nov, 1992 ;;;;;
                          #;(if (macro-function fun)
                              (c1expr ((macro-function fun) form))
                              (c1symbol-fun fun args)))))
                 ((and (pair? fun) (eq? (car fun) 'lambda))
                  (c1lambda-fun (cdr fun) args))
                 (else (list #;c2funcall (c1expr fun) (c1args args))))))
        (else
          (case form
            ((#f) c1false)
            ((#t) c1true)
            ((()) c1null)
            (else (c1constant form))))))

(define (c1symbol-fun name args)
  (let parse ((env *env*) (ccb #f))
    (cond ((null? env) `(,name ,(c1args args))
           #;`(,c2funcall (,c2gvref ,name) ,(c1args args)))
          ((eq? (car env) 'CB) (parse (cdr env) #t))
          ((eq? (var-name (car env)) name)
           (if ccb (set-var-closed (car env) #t))
           `(,(car env) ,(c1args args))
           #;`(,c2funcall (,c2vref ,(car env) ,ccb) ,(c1args args)))
          (else (parse (cdr env) ccb)))))

(define (c1lambda-fun lambda-expr args)
  (define (make-defs vl as)
    (cond ((null? vl)
           (if (not (null? as))
               (scerror "Illegal number of arguments.~%        In ~s"
                        (cons (cons 'lambda lambda-expr)
                              args))
               '()))
          ((symbol? vl) `((,vl (list ,@as))))
          (else
            (if (null? as) 
                (scerror "Illegal number of arguments.~%        In ~s"
                         (cons (cons 'lambda lambda-expr)
                               args))
                (cons (list (car vl) (car as))
                      (make-defs (cdr vl) (cdr as)))))))
  (if (end? lambda-expr)
      (scbad-args 'lambda lambda-expr)
      (c1let (cons (make-defs (car lambda-expr) args) (cdr lambda-expr)))))

(define (c1args forms)
  (if (end? forms)
      '()
      (cons (c1expr (car forms)) (c1args (cdr forms)))))

(define (c2expr form) (apply (car form) (cdr form)))

(define (c2push-expr* form)
  (dlet ((*value-to-go* 'PUSH) (*exit* 'NEXT) (*exit-label* (next-label)))
    (c2expr form)
    (wt-label *exit-label*)
    (set! *sp* (- *sp* 1))))

(define (c2get-expr* form)
  (dlet ((*value-to-go* 'BX) (*exit* 'NEXT) (*exit-label* (next-label)))
    (c2expr form)
    (wt-label *exit-label*)))

(define (c2funcall fun args)
  (if (and (eq? (car fun) c2vref) (var-local-fun (cadr fun)))
      (if (let* ((actuals (length args))
                 (x (var-local-fun-args (cadr fun)))
                 (requireds (length (car x))))
            (or (< actuals requireds)
                (and (null? (cadr x)) (> actuals requireds))))
          (scerror "Wrong number of args to the local fun ~s."
            (var-name (cadr fun)))
          (case *exit*
            ((XRETURN LRETURN)
             (cond ((< *level* (var-local-fun (cadr fun)))
                    (c2lcall *exit* fun args))
                   ((and (= *level* (var-local-fun (cadr fun)))
                         (not (null? args))
                         (null? (cdr args))
                         (= *sp* -1))
                    (c2get-expr* (car args))
                    (wt '(set-lval0 -1))
                    (wt `(lcall ,(touch-label (var-loc (cadr fun))))))
                   (else
                    (dlet ((*bp* *bp*) (*sp* *sp*))
                      (if (not (null? args))
                          (do ((x args (cdr x)))
                              ((null? (cdr x))
                               (c2get-expr* (car x)))
                            (c2push-expr* (car x))))
                      (wt `(trlcall ,(- *level* (var-local-fun (cadr fun)))
                                    ,(length args)
                                    ,(touch-label (var-loc (cadr fun)))))))))
            (else (cond ((and (not (eq? *value-to-go* 'PUSH))
                              (or (eq? *exit* 'NEXT) (eq? *exit* 'ESCAPE)))
                         (c2lcall (touch-label *exit-label*) fun args))
                        (else (let ((label (next-label2)))
                                (c2lcall (touch-label label) fun args)
                                (wt-label label))
                              (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
                              (cmp:exit))))))

      (or (and *inline-functions* (c2call-simple-function fun args))
          (case *exit*
            ((XRETURN LRETURN)
             (dlet ((*bp* *bp*) (*sp* *sp*))
               (if (null? args)
                   (c2get-expr* fun)
                   (begin (c2push-expr* fun)
                          (do ((x args (cdr x)))
                              ((null? (cdr x))
                               (c2get-expr* (car x)))
                              (c2push-expr* (car x)))))
               (wt `(,(if (eq? *exit* 'XRETURN) 'trcall 'ltrxcall)
                      ,(length args)))))
            (else (cond ((and (not (eq? *value-to-go* 'PUSH))
                              (or (eq? *exit* 'NEXT) (eq? *exit* 'ESCAPE)))
                         (c2xcall *exit-label* fun args))
                        (else (let ((label (next-label2)))
                                   (c2xcall label fun args)
                                   (wt-label label))
                              (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
                              (cmp:exit))))))))

(define (c2lcall return fun args)
  (dlet ((*bp* *bp*) (*sp* *sp*))
    (let ((level (- *level* (var-local-fun (cadr fun)))))
      (if (negative? level)
          (wt `(open-lframe-1 ,*bp* ,return))
          (wt `(open-lframe ,*bp* ,level ,return))))
    (for-each c2push-expr* args)
    (wt `(lcall ,(touch-label (var-loc (cadr fun))) ,return))))

(define (c2xcall return fun args)
  (dlet ((*bp* *bp*) (*sp* *sp*))
    (wt `(open-frame ,(touch-label return)))
    (c2push-expr* fun)
    (for-each c2push-expr* args)
    (wt `(xcall ,(cdr return)))))

(define (c2call-simple-function fun args)
  (and (eq? (car fun) c2gvref)
       (case (cadr fun)
         ((car cdr not null? caar cadr cdar cddr pair? symbol? zero? 1+ 1-
           vector? vector-length
           $$car $$cdr $$not $$null? $$caar $$cadr $$cdar $$cddr $$pair?
           $$symbol? $$zero? $$1+ $$1- $$vector? $$vector-length)
          (and (not (null? args))
               (null? (cdr args))
               (begin (c2get-expr* (car args))
                      (wt (case (cadr fun)
                            ((car $$car) '(get-car))
                            ((cdr $$cdr) '(get-cdr))
                            ((not $$not) '(not))
                            ((null? $$null?) '(null?))
                            ((caar $$caar) '(get-caar))
                            ((cadr $$cadr) '(get-cadr))
                            ((cdar $$cdar) '(get-cdar))
                            ((cddr $$cddr) '(get-cddr))
                            ((pair? $$pair?) '(pair?))
                            ((symbol? $$symbol?) '(symbol?))
                            ((zero? $$zero?) '(zero?))
                            ((1+ $$1+) '(1+))
                            ((1- $$1-) '(1-))
                            ((vector? $$vector?) '(vector?))
                            ((vector-length $$vector-length)
                             '(vector-length))))
                      (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
                      (cmp:exit) #t)))
         ((cons $$cons)
          (and (not (null? args))
               (not (null? (cdr args)))
               (null? (cddr args))
               (begin
                (cond ((eq? (caar args) c2constant)
                       (c2get-expr* (cadr args))
                       (wt `(make-cons1 ,(cadar args))))
                      ((eq? (caadr args) c2constant)
                       (c2get-expr* (car args))
                       (wt (if (null? (cadadr args))
			       '(ncons)
			       `(make-cons2 ,(cadadr args)))))
                      (else
                       (c2push-expr* (car args))
                       (c2get-expr* (cadr args))
                       (wt '(make-cons))))
                (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
                (cmp:exit) #t)))
         ((list $$list)
          (cond ((null? args) (c2constant '()))
                ((<= (length args) 5)
                 (do ((x args (cdr x)))
                     ((null? (cdr x))
                      (c2get-expr* (car x))
                      (wt '(ncons)))
                   (c2push-expr* (car x)))
                 (dotimes (i (- (length args) 1)) (wt '(make-cons)))
                 (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
                 (cmp:exit) #t)
                (else #f)))
         ((eq? eqv? equal? $$eq? $$eqv? $$equal?)
          (and (not (null? args))
               (not (null? (cdr args)))
               (null? (cddr args))
               (begin
                (cond ((eq? (caar args) c2constant)
                       (c2get-expr* (cadr args))
                       (wt (list (case (cadr fun)
                                   ((eq? $$eq?) 'eq-const?)
                                   ((eqv? $$eqv?) 'eqv-const?)
                                   ((equal? $$equal?) 'equal-const?))
                                 (cadar args))))
                      ((eq? (caadr args) c2constant)
                       (c2get-expr* (car args))
                       (wt (if (not (null? (cadadr args)))
                               (list (case (cadr fun)
                                       ((eq? $$eq?) 'eq-const?)
                                       ((eqv? $$eqv?) 'eqv-const?)
                                       ((equal? $$equal?) 'equal-const?))
                                     (cadadr args))
                               '(null?))))
                      (else
                       (c2push-expr* (car args))
                       (c2get-expr* (cadr args))
                       (wt (case (cadr fun)
                             ((eq? $$eq?) '(eq?))
                             ((eqv? $$eqv?) '(eqv?))
                             ((equal? $$equal?) '(equal?))))))
                (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
                (cmp:exit) #t)))
         ((+ * - / < > <= >= = set-car! set-cdr! vector-ref
           $$+ $$* $$- $$/ $$< $$> $$<= $$>= $$= $$set-car! $$set-cdr!
           $$vector-ref)
          (and (not (null? args))
               (or (and (not (null? (cdr args)))
                        (null? (cddr args))
                        (begin
                          (c2push-expr* (car args))
                          (c2get-expr* (cadr args))
                          (wt (case (cadr fun)
                                ((+ $$+) '(+))
                                ((* $$*) '(*))
                                ((- $$-) '(-))
                                ((/ $$/) '(/))
                                ((< $$<) '(<))
                                ((> $$>) '(>))
                                ((<= $$<=) '(<=))
                                ((>= $$>=) '(>=))
                                ((= $$=) '(=))
                                ((set-car! $$set-car!) '(set-car!))
                                ((set-cdr! $$set-cdr!) '(set-cdr!))
                                ((vector-ref $$vector-ref) '(vector-ref))))
                          (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
                          (cmp:exit) #t))
                   (case (cadr fun)
                     ((- / $$- $$/)
                      (and (null? (cdr args))
                           (begin
                             (c2get-expr* (car args))
                             (wt (case (cadr fun)
                                   ((- $$-) '(0-))
                                   ((/ $$/) '(1/))))
                             (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
                             (cmp:exit) #t)))
                     (else #f)))))
         ((vector-set! $$vector-set!)
          (and (not (null? args))
               (not (null? (cdr args)))
               (not (null? (cddr args)))
               (null? (cdddr args))
               (begin
                 (c2push-expr* (caddr args))
                 (c2push-expr* (car args))
                 (c2get-expr* (cadr args))
                 (wt '(vector-set!))
                 (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
                 (cmp:exit) #t)))
         (else #f))))

(define (c1begin forms)
  (cond ((end? forms) c1begin-empty-default)
        ((end? (cdr forms)) (c1expr (car forms)))
        (else (list 'begin #;c2begin (c1map c1expr forms)))))

(define (c2begin forms)
  (do ((l forms (cdr l)))
      ((null? (cdr l)) (c2expr (car l)))
    (dlet ((*value-to-go* 'TRASH) (*exit* 'NEXT) (*exit-label* (next-label)))
      (c2expr (car l))
      (wt-label *exit-label*))))

(define (c1body body defs)
  (if (end? body)
      (if (not (null? defs))
          (c1letrec (list (reverse defs)))
          c1begin-empty-default)
      (let ((form (car body)))
        (cond ((and (pair? form) (eq? (car form) 'define))
               (if (or (end? (cdr form))
                       (end? (cddr form)) )
;                       (not (end? (cdddr form))))
                   (scbad-args 'define (cdr form)))
               (c1body (cdr body)
                       (cons (if (pair? (cadr form))
                                 `(,(caadr form)
                                    (lambda ,(cdadr form) ,@(cddr form)))
                                 (cdr form))
                             defs)))
              ((null? defs)
               (c1begin body))
              (else
               (c1letrec (cons (reverse defs) body)))))))

;;; SCEXIT  Exit Manager.

(define *value-to-go* 'BX)
(define *exit* 'XRETURN)
(define *exit-label* '())
(define *unwind-sp* 0)

(define (cmp:exit)
  (case *exit*
    ((ESCAPE) (wt `(jmp ,(touch-label *exit-label*))))
    ((UNWIND-NEXT) (wt-reset-sp *unwind-sp*))
    ((UNWIND-ESCAPE) (wt-reset-sp *unwind-sp*)
                     (wt `(jmp ,(touch-label *exit-label*))))
    ((XRETURN) (wt '(xreturn)))
    ((LRETURN) (wt '(lreturn)))))

(define (exit-always)
  (case *exit*
    ((NEXT ESCAPE) (wt `(jmp ,(touch-label *exit-label*))))
    ((UNWIND-NEXT UNWIND-ESCAPE) (wt-reset-sp *unwind-sp*)
                                 (wt `(jmp ,(touch-label *exit-label*))))
    ((XRETURN) (wt '(xreturn)))
    ((LRETURN) (wt '(lreturn)))))

;;; SCFUNC  Lambda Expression.

(define (c1lambda args)
  (dlet ((*env* (cons 'CB *env*)))
        (cons 'lambda #;c2lambda (cons (cons 'lambda args) (c1lam args)))))

(define (c1delay args)
  (dlet ((*env* (cons 'CB *env*)))
    (cons 'delay #;c2delay (cddr (c1lam (cons '() args))))))

(define (c1lam lambda-expr)
  (if (end? lambda-expr) (scbad-args 'lambda lambda-expr))
  (let ((requireds '()) (rest '()))
    (dlet ((*env* *env*))
      (do ((vl (car lambda-expr) (cdr vl)))
          ((not (pair? vl))
           (if (not (null? vl))
               (let ((var (make-var vl)))
                 (set! *env* (cons var *env*))
                 (set! rest var)))
           (list (reverse requireds)
                 rest
                 (c1body (cdr lambda-expr) '())))
        (let ((var (make-var (car vl))))
          (set! requireds (cons var requireds))
          (set! *env* (cons var *env*)))))))

(define (make-arg-info requireds rest)
  (if (null? rest)
      (* (+ requireds 1) 4)
      (+ (* (+ requireds 1) 8) 3)))

(define (c2lambda lam requireds rest body)
  (if (zero? *re-compile-level*) (set! lam '())) ;;;;; By A243  Dec, 1992 ;;;;
  (if (not (eq? *value-to-go* 'TRASH))
    (let ((label (next-label2))
          (arg-info (make-arg-info (length requireds) rest)))
      (cond ((null? *clink*)
             ;; for DOS
             ;(set! *cclosures*
             ;      (cons (list label *ccb-vs* requireds rest body)
             ;            *cclosures*))
             ;; for UNIX
             (set! *cclosures*
                (cons (list c2local-lam label requireds rest body)
                         *cclosures*))
             ;;
             (wt `(make-nil-closure ,arg-info ,(touch-label label) ,lam)))
            (else 
             ;; for DOS
             ;(set! *cclosures*
             ;      (cons (list label *ccb-vs* requireds rest body)
             ;            *cclosures*))
             ;; for UNIX
             (set! *cclosures*
                   (cons (list c2cclosure label *ccb-vs* requireds rest body)
                         *cclosures*))
             ;;
             (wt (if (= (car *clink*) *level*)
                     `(get-lval0 ,(- (cdr *clink*) *bp*))
                     `(get-lval ,*bp* ,(- *level* (car *clink*))
                                ,(cdr *clink*))))
             (wt `(make-closure ,arg-info ,(touch-label label) ,lam))))
      (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))))
  (cmp:exit))

(define (c2delay body)
  (if (not (eq? *value-to-go* 'TRASH))
      (let ((label (next-label2)))
        (set! *cclosures*
              ;; for DOS
              ;(cons (list label *ccb-vs* '() '() body)
              ;      *cclosures*)
              ;; for UNIX
              (cons (list c2cclosure label *ccb-vs* '() '() body)
                    *cclosures*)
              ;;
              )
        (wt (cond ((null? *clink*) '(get-const ()))
                  ((= (car *clink*) *level*)
                   `(get-lval0 ,(- (cdr *clink*) *bp*)))
                  (else `(get-lval ,*bp* ,(- *level* (car *clink*))
                                   ,(cdr *clink*)))))
        (wt `(make-promise ,(touch-label label)))
        (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))))
  (cmp:exit))

(define (c2lam label requireds rest body)
  (wt-label label)
  (dlet ((*cenv-length* 0) (*cenv-loc* '()) (*clink* '()) (*ccb-vs* 0)
         (*level* 0) (*bp* 0) (*sp* -1))
    (for-each c2lambda-bind requireds)
    (if (not (null? rest)) (c2lambda-bind rest))
    (dlet ((*value-to-go* 'BX) (*exit* 'XRETURN)) (c2expr body))))

(define (c2local-lam label requireds rest body)
  (let ((magic (begin-local-function)))
    (wt-label label)
    (dlet ((*cenv-length* 0) (*cenv-loc* '()) (*clink* '()) (*ccb-vs* 0)
           (*level* 0) (*bp* 0) (*sp* -1))
      (for-each c2lambda-bind requireds)
      (if (not (null? rest)) (c2lambda-bind rest))
      (dlet ((*value-to-go* 'BX) (*exit* 'XRETURN)) (c2expr body)))
    (end-local-function magic)))

(define (c2cclosure label cenv-length requireds rest body)
  (dlet ((*cenv-length* cenv-length))
    (let ((magic (begin-local-function)))
      (wt-label label)
      (dlet ((*cenv-loc* (- 0 (length requireds) (if (null? rest) 2 3))))
        (dlet ((*clink* (cons 0 *cenv-loc*)) (*ccb-vs* *cenv-length*)
               (*level* 0) (*bp* 0) (*sp* -1))
          (for-each c2lambda-bind requireds)
          (if (not (null? rest)) (c2lambda-bind rest))
          (set! *sp* (- *sp* 1))
          (dlet ((*value-to-go* 'BX) (*exit* 'XRETURN)) (c2expr body))))
      (end-local-function magic))))

(define (c2local-fun label cenv-length cenv-loc clink ccb-vs level
                     requireds rest body)
  (dlet ((*cenv-length* cenv-length) (*cenv-loc* cenv-loc) (*clink* clink)
         (*ccb-vs* ccb-vs) (*level* level))
    (let ((magic (begin-local-function)))
      (wt-label label)
      (dlet ((*bp* 0) (*sp* 0))
        (for-each c2lambda-bind requireds)
        (if (not (null? rest))
            (begin (wt `(make-rest ,(- *sp* 1))) (c2lambda-bind rest)))
        (dlet ((*value-to-go* 'BX) (*exit* 'LRETURN)) (c2expr body)))
      (end-local-function magic))))

;;; SCLETS  Let, Let*, and Letrec.

(define (make-var name)
  (if (symbol? name)
      (if (member name '(if cond case and or begin lambda delay let let* 
                          letrec do set! quote quasiquote define macro))
          (scerror "Cannot bind the keyword ~s." name)
          (list name #f #f #f #f '() '()))
      (scerror "~s is not a symbol." name)))
(define (var-name var) (car var))
(define (var-funarg var) (cadr var))
(define (var-assigned var) (caddr var))
(define (var-closed var) (cadddr var))
(define (var-local-fun var) (car (cddddr var)))
(define (var-local-fun-args var) (cadr (cddddr var)))
(define (var-loc var) (caddr (cddddr var)))

(define (set-var-name var x) (set-car! var x))
(define (set-var-funarg var x) (set-car! (cdr var) x))
(define (set-var-assigned var x) (set-car! (cddr var) x))
(define (set-var-closed var x) (set-car! (cdddr var) x))
(define (set-var-local-fun var x) (set-car! (cddddr var) x))
(define (set-var-local-fun-args var x) (set-car! (cdr (cddddr var)) x))
(define (set-var-loc var x) (set-car! (cddr (cddddr var)) x))

(define *env* '())

(define (c1let args)
  (if (end? args) (scbad-args 'let args))
  (if (symbol? (car args))
      (if (end? (cdr args))
          (scbad-args 'let args)
          (c1named-let (car args) (cadr args) (cddr args)))
      (let ((body '()) (defs '()))
        (dlet ((*env* *env*))
          (dolist (def (car args))
            (if (or (end? def) (end? (cdr def)) (not (end? (cddr def))))
                (scbad-binding def))
            (let ((var (make-var (car def))))
              (set! defs (cons (cons var (cadr def)) defs))
              (set! *env* (cons var *env*))))
          (set! body (c1body (cdr args) '())))
        (dolist (def defs)
                (let ((var (car def))
                      (form (cdr def))
                      (c.scm:free-vars (c.scm:difference *env* (map car defs)))) ;; c.scm この時点での自由変数
            (if (and (pair? form) (eq? (car form) 'lambda #;'LAMBDA)) ;; c.scm
                (if (or (var-funarg var) (var-assigned var) (var-closed var))
                    (set-cdr! def (c1lambda (cdr form)))
                    (begin (set-cdr! def (c1lam (cdr form)))
                           (set-var-local-fun var #t)
                           (let ((requireds (cadr def)) ;; c.scm, #tの代わりに自由変数のリストをおく
                                 (rest (caddr def)))
                             (set-var-local-fun var (c.scm:reduction (reverse (c.scm:difference (c.scm:difference c.scm:free-vars requireds)
                                                                               rest)))))
                           (set-var-local-fun-args var (cdr def))))
                (set-cdr! def (c1expr form)))))
        (list 'let #;c2let (reverse defs) body))))

(define (c1let* args)
  (if (end? args) (scbad-args 'let* args))
  (let ((body '()) (defs '()))
    (dlet ((*env* *env*))
      (dolist (def (car args))
        (if (or (end? def) (end? (cdr def)) (not (end? (cddr def))))
            (scbad-binding def))
        (let ((var (make-var (car def))))
          (set! defs (cons (cons var (cadr def)) defs))
          (set! *env* (cons var *env*))))
      (set! body (c1body (cdr args) '()))
      (dolist (def defs)
        (set! *env* (cdr *env*))
        (let ((var (car def))
              (form (cdr def)))
          (if (and (pair? form) (eq? (car form) 'lambda #;'LAMBDA)) ;; c.scm
              (if (or (var-funarg var) (var-assigned var) (var-closed var))
                  (set-cdr! def (c1lambda (cdr form)))
                  (begin (set-cdr! def (c1lam (cdr form)))
                         (set-var-local-fun var #t)
                         (let ((requireds (cadr def)) ;; c.scm, #tの代わりに自由変数のリストをおく
                               (rest (caddr def)))
                           (set-var-local-fun var (c.scm:reduction (reverse (c.scm:difference (c.scm:difference *env* requireds)
                                                                             rest)))))
                         (set-var-local-fun-args var (cdr def))))
              (set-cdr! def (c1expr form))))))
    (list 'let* #;c2let* (reverse defs) body)))

(define (c1letrec args)
  (if (end? args) (scbad-args 'letrec args))
  (let ((body '()) (defs '()))
    (dlet ((*env* *env*))
          (dolist (def (car args))
                  (if (or (end? def) (end? (cdr def)) (not (end? (cddr def))))
                      (scbad-binding def))
                  (let ((var (make-var (car def))))
                    (set! defs (cons (list var '() (cadr def)) defs))
                    (set! *env* (cons var *env*))))
          (set! body (c1body (cdr args) '()))

          (dolist (def defs)
                  (let ((var (car def))
                        (form (caddr def))
                        (c.scm:free-vars (c.scm:difference *env* (map car defs)))) ;; c.scm, この時点での自由変数
                    (if (and (pair? form) (eq? (car form) 'lambda #;'LAMBDA))
                        (if (or (var-funarg var) (var-assigned var) (var-closed var))
                            (set-car! (cdr def) (c1lambda (cdr form)))
                            (begin (set-car! (cdr def) (c1lam (cdr form)))
                                   (set-var-local-fun var #t)
                                   (let ((requireds (caadr def)) ;; c.scm, #tの代わりに自由変数のリストをおく
                                         (rest (cadadr def)))
                                     (set-var-local-fun var (c.scm:reduction (reverse (c.scm:difference (c.scm:difference c.scm:free-vars requireds)
                                                                                       rest)))))
                                   (set-var-local-fun-args var (cadr def))))
                        (set-car! (cdr def) (c1expr form)))))

          (c1letrec-aux defs))
    (list 'letrec #;c2letrec (reverse defs) body)))

(define (c1letrec-aux defs)
  (define (parse defs)
    (if (null? defs)
        #f
        (let* ((def (car defs)) (var (car def)))
          (if (and (var-local-fun var)
                   (or (var-funarg var) (var-assigned var) (var-closed var)))
              (begin (set-var-local-fun var #f)
                     (set-car! (cdr def) (c1lambda (cdaddr def)))
                     (parse (cdr defs))
                     #t)
              (parse (cdr defs))))))
  (if (parse defs) (c1letrec-aux defs)))

(define (c1named-let name bind body)
  (let ((var (make-var name))
        (inits (c1map (lambda (x)
                        (if (or (end? x) (end? (cdr x))
                                (not (end? (cddr x))))
                            (scbad-binding x))
                        (c1expr (cadr x))) 
                      bind))
        (vars (c1map car bind)))
    (dlet ((*env* (cons var *env*)))
      (let* ((arg-body (cons vars body)) 
             (fun (c1lam arg-body)))
        (cond ((or (var-funarg var) (var-assigned var) (var-closed var))
               (list 'let #;c2named-let var inits (c1lambda arg-body)))
              (else (set-var-local-fun var #t)
                    (set-var-local-fun-args var (list vars #f))
                    (list 'let #;c2named-let var inits fun)))))))

(define (c1do args)
  (if (or (end? args) (end? (cdr args)) (end? (cadr args)))
      (scbad-args 'do args))
  (let ((name (gensym)))
;    (c1named-let name (car args)
    (c1named-let name (c1map (lambda (x) (list (car x) (cadr x))) (car args))
      `((if ,(caadr args)
            (begin ,@(cdadr args))
            (begin ,@(cddr args)
                   ,(cons name
                          (c1map (lambda (ite)
                                   (cond ((or (end? ite) (end? (cdr ite)))
                                          (scbad-binding ite))
                                         ((end? (cddr ite))
                                          (car ite))
                                         ((end? (cdddr ite))
                                          (caddr ite))
                                         (else (scbad-binding ite))))
                                 (car args)))))))))

(define (c2let defs body)
  (dlet ((*sp* *sp*))
    (dolist (def defs)
      (let ((var (car def)) (form (cdr def)))
        (cond ((var-local-fun var)
               (set-var-local-fun var (+ *level* 1))
               (set-var-loc var (next-label2))
               (set! *local-funs*
                     (cons (list* (var-loc var) *cenv-length* *cenv-loc*
                                  *clink* *ccb-vs* (+ *level* 1) form)
                           *local-funs*)))
              (else (c2push-expr* form))))))
  (dlet ((*sp* *sp*) (*clink* *clink*) (*ccb-vs* *ccb-vs*))
    (let ((old-sp *sp*) (unwindp #f))
      (dolist (def defs)
        (if (not (var-local-fun (car def)))
            (begin (c2lambda-bind (car def))
                   (set! unwindp #t))))
      (c2let-body unwindp old-sp body))))

(define (c2let* defs body)
  (dlet ((*sp* *sp*) (*clink* *clink*) (*ccb-vs* *ccb-vs*))
    (let ((old-sp *sp*) (unwindp #f))
      (dolist (def defs)
        (let ((var (car def)) (form (cdr def)))
          (cond ((var-local-fun var)
                 (set-var-local-fun var (+ *level* 1))
                 (set-var-loc var (next-label2))
                 (set! *local-funs*
                       (cons (list* (var-loc var) *cenv-length* *cenv-loc*
                                    *clink* *ccb-vs* (+ *level* 1) form)
                             *local-funs*)))
                (else (set! unwindp #t)
                      (c2push-expr* form)
                      (c2bind var)))))
      (c2let-body unwindp old-sp body))))

(define (c2letrec defs body)
  (dlet ((*clink* *clink*) (*ccb-vs* *ccb-vs*))
    (dlet ((*sp* *sp*))
      (let ((old-sp *sp*) (unwindp #f))
        (dolist (def defs)
          (if (not (var-local-fun (car def)))
              (begin (wt '(push-const ())) (set! *sp* (- *sp* 1))
                     (c2bind (car def)))))
        (dolist (def defs)
          (let ((var (car def)) (form (cadr def)))
            (cond ((var-local-fun var)
                   (set-var-local-fun var (+ *level* 1))
                   (set-var-loc var (next-label2))
                   (set! *local-funs*
                         (cons (list* (var-loc var)
                                      *cenv-length* *cenv-loc* *clink*
                                      *ccb-vs* (+ *level* 1) form)
                               *local-funs*)))
                  (else (set! unwindp #t)
                        (c2get-expr* form)
                        (wt `(,(if (or (var-assigned var) (var-closed var))
                                   'set-hval0 'set-lval0)
                               ,(- (cdr (var-loc var)) *bp*)))))))
        (c2let-body unwindp old-sp body)))))

(define (c2let-body unwindp old-sp body)
  (if unwindp
      (case *exit*
        ((NEXT)
         (cond ((eq? *value-to-go* 'PUSH)
                (c2get-expr* body)
                (wt-reset-sp old-sp)
                (wt '(push-bx)))
               (else (dlet ((*exit* 'UNWIND-NEXT) (*unwind-sp* old-sp))
                       (c2expr body)))))
        ((ESCAPE)
         (cond ((eq? *value-to-go* 'PUSH)
                (c2get-expr* body)
                (wt-reset-sp old-sp)
                (wt '(push-bx))
                (cmp:exit))
               (else (dlet ((*exit* 'UNWIND-ESCAPE) (*unwind-sp* old-sp))
                       (c2expr body)))))
        (else (c2expr body)))
      (c2expr body)))

(define (c2named-let var inits form)
  (let ((vref (list c2vref var #f)))
    (cond ((var-local-fun var)
           (set-var-local-fun var (+ *level* 1))
           (set-var-loc var (next-label2))
           (set! *local-funs*
                 (cons (list* (var-loc var) *cenv-length* *cenv-loc* *clink*
                              *ccb-vs* (+ *level* 1) form)
                       *local-funs*))
           (c2funcall vref inits))
          (else
           (dlet ((*sp* *sp*) (*clink* *clink*) (*ccb-vs* *ccb-vs*))
             (let ((old-sp *sp*))
               (wt '(push-const ())) (set! *sp* (- *sp* 1))
               (c2bind var)
               (c2get-expr* form)
               (wt `(set-hval0 ,(- (cdr (var-loc var)) *bp*)))
               (c2let-body #t old-sp (list c2funcall vref inits))))))))

;;; SCLOAD  The Loader

(define *open-frame-pushes* 5)
(define *open-lframe-pushes* 4)
(define *last-label* 0)

(define (next-label2)
  (set! *last-label* (+ *last-label* 1))
  (cons *last-label*
        (string->symbol
         (string-append "L" (number->string *last-label* 10)))))

(define (next-label)
  (set! *last-label* (+ *last-label* 1))
  (cons *last-label* #f))

(define (touch-label label)
  (or (cdr label)
      (begin (set-cdr! label
                       (string->symbol
                        (string-append "L"
                                       (number->string (car label) 10))))
             (cdr label))))

(define (begin-local-function)
  *bc-codep*)

(define (end-local-function saved-codep)
  (set-cdr! saved-codep 
    (list (cons 'local-function (cdr saved-codep))))
  (set! *bc-codep* (cdr saved-codep)))

(define (wt-label label)
  (if (cdr label) (wt (cdr label))))

(define (wt-reset-sp sp)
  (if (not (= sp *sp*)) (wt `(reset-sp ,(- sp *sp*)))))

(define (wt code)
  (set-cdr! *bc-codep* (list code))
  (set! *bc-codep* (cdr *bc-codep*))
  (if (pair? code)
      (case (car code)
        ((open-frame)
         (set! *sp* (- *sp* *open-frame-pushes*))
         (set! *bp* *sp*))
        ((open-lframe open-lframe-1)
         (set! *sp* (- *sp* *open-lframe-pushes*))
         (set! *bp* *sp*))
        ((make-cons eq? eqv? equal? + * - / < > <= >= =
          set-car! set-cdr! vector-ref)
         (set! *sp* (+ *sp* 1)))
        ((vector-set!) (set! *sp* (+ *sp* 2))))))

(define (wt-begin)
  (set! *bc-code* (list ()))
  (set! *bc-codep* *bc-code*))

(define (wt-end-function first func-name args)
  `(,first ,func-name 
     (COMPILED-FUNCTION ',func-name 
       ,(do ((x (cdr args) (cdr x)) (n 0 (+ n 1)))
          ((not (pair? x)) (make-arg-info n x)))
       ',(cdr *bc-code*))))

(define (wt-end-expr)
  `(LOAD-TIME-EVAL ',(cdr *bc-code*)))

;;; SCMISC  Miscellaneous Special Forms.

(define (c1quote args)
  (if (or (end? args) (not (end? (cdr args)))) (scbad-args 'quote args))
  (case (car args)
    ((#f) c1false)
    ((#t) c1true)
    ((()) c1null)
    (else (c1constant (car args)))))

;(define (c1quasiquote args)
;  (define (qqcons a b)
;    (if (pair? b)
;        (case (car b)
;          ((list) `(list ,a ,@(cdr b)))
;          ((list* cons) `(list* ,a ,@(cdr b)))
;          (else `(cons ,a ,b)))
;        `(cons ,a ,b)))
;  (define (qqquote x) (if (or (symbol? x) (pair? x)) `',x x))
;  (define (qq x)
;    (cond ((pair? x)
;           (let ((a (car x)) (b (cdr x)))
;             (cond ((eq? a 'unquote) (car b))
;                   ((null? b)
;                    (cond ((and (pair? a) (eq? (car a) 'unquote))
;                           `(list ,(cadr a)))
;                          ((and (pair? a) (eq? (car a) 'unquote-splicing))
;                           (cadr a))
;                          (else (let ((aa (qq a)))
;                                  (if (eq? aa a) x `(list ,aa))))))
;                   (else
;                     (let ((bb (qq b)))
;                       (cond ((and (pair? a) (eq? (car a) 'unquote))
;                              (if (eq? bb b)
;                                  `(cons ,(cadr a) ,(qqquote b))
;                                  (qqcons (cadr a) bb)))
;                             ((and (pair? a) (eq? (car a) 'unquote-splicing))
;                              (cond ((eq? bb b)
;                                     `(append ,(cadr a) ,(qqquote b)))
;                                    ((and (pair? bb) (eq? (car bb) 'append))
;                                     `(append ,(cadr a) ,@(cdr bb)))
;                                    (else `(append ,(cadr a) ,bb))))
;                             (else (let ((aa (qq a)))
;                                     (if (eq? aa a)
;                                         (if (eq? bb b) x
;                                             (qqcons (qqquote a) bb))
;                                         (if (eq? bb b)
;                                             (qqcons aa (qqquote b))
;                                             (qqcons aa bb)))))))))))
;      ((vector? x)
;       (if (let variable-length? ((i (- (vector-length x) 1)))
;             (if (negative? i) #f
;                 (or (and (pair? (vector-ref x i))
;                          (eq? (car (vector-ref x i)) 'unquote-splicing))
;                     (variable-length? (- i 1)))))
;           `(list->vector ,(qq (vector->list x)))
;           (let ((y (vector->list x)))
;             (if (eq? (qq y) y) x
;                 `(vector
;                    ,@(let qqelem ((l y))
;                        (if (null? l) '()
;                            (cons (let ((aa (qq (car l))))
;                                    (if (eq? aa (car l))
;                                        (qqquote aa)
;                                        aa))
;                                  (qqelem (cdr l))))))))))
;      (else x)))
;  (if (or (end? args) (not (end? (cdr args)))) (scbad-args 'quasiquote args))
;  (let ((xx (qq (car args))))
;    (c1expr (if (eq? xx (car args)) (qqquote xx) xx))))

;;; Quasiquote by T.Komiya

(let () (append))

(define (c1quasiquote args)
  (define (qq x level)
    (cond ((vector? x)
           `(list->vector ,(qq (vector->list x) level)))
          ((not (pair? x)) (if (symbol? x) `',x x))
          ((eq? (car x) 'quasiquote)
           `($$cons ,''quasiquote ,(qq (cdr x) (1+ level))))
          ((eq? (car x) 'unquote)
           (let ((xcdr (cdr x)))
             (if (or (not (pair? xcdr))
                     (not (null? (cdr xcdr))))
                 (scbad-args 'unquote xcdr)
                 (if (zero? level)
                     (car xcdr)
                     `($$cons ,''unquote ,(qq xcdr (1- level)))))))
          ((and (pair? (car x)) (eq? (caar x) 'unquote-splicing))
           (let ((xcar (car x)) (xcdr (cdr x)))
             (if (or (not (pair? (cdr xcar)))
                     (not (null? (cddr xcar))))
                 (scbad-args 'unquote-splicing xcar))
             (if (zero? level)
                 `($$append ,(cadr xcar) ,(qq xcdr level))
                 `($$cons ($$cons ,''unquote-splicing ,(qq (cdr xcar) (1- level)))
                        ,(qq xcdr level)))))
          (else
            `($$cons ,(qq (car x) level) ,(qq (cdr x) level)))))
  (if (or (end? args) (not (end? (cdr args)))) (scbad-args 'quasiquote args))
  (c1expr (qq (car args) 0)))

(define (c1define args)
  (scerror "Bad use of DEFINE."))

(define (c1macro args)
  (scerror "Bad use of MACRO."))

;;; SCVREF  Variable References.

(define (c1vref name)
  (let lookup ((env *env*) (ccb #f))
    (if (null? env)
        name ;; c.scm:c1
        #;(list c2gvref name)
        (let ((var (car env)))
          (cond ((eq? var 'CB) (lookup (cdr env) #t))
                ((eq? (var-name var) name)
                 (if ccb (set-var-closed var #t))
                 (set-var-funarg var #t)
                 var ;; c.scm:c1
                 #;(list c2vref var ccb))
                (else (lookup (cdr env) ccb)))))))

(define (c1lookup name)
  (let lookup ((env *env*))
    (cond ((null? env) #f)
          ((and (not (eq? (car env) 'CB))
                (eq? (var-name (car env)) name))
           #t)
          (else (lookup (cdr env))))))

(define (c2vref var ccb)
  (if (not (eq? *value-to-go* 'TRASH))
    (cond (ccb 
           (let ((n (- *cenv-length* (var-closed var) 1)))
             (if (zero? *level*)
                 (case *value-to-go*
                   ((BX) (wt `(get-cval0 ,(- *cenv-loc* *bp*) ,n)))
                   ((PUSH) (wt `(push-cval0 ,(- *cenv-loc* *bp*) ,n))))
                 (case *value-to-go*
                   ((BX) (wt `(get-cval ,*bp* ,*level* ,*cenv-loc* ,n)))
                   ((PUSH)
                    (wt `(push-cval ,*bp* ,*level* ,*cenv-loc* ,n)))))))
          ((= (car (var-loc var)) *level*)
           (let ((offset (- (cdr (var-loc var)) *bp*)))
             (if (or (var-assigned var) (var-closed var))
                 (case *value-to-go*
                   ((BX) (wt `(get-hval0 ,offset)))
                   ((PUSH) (wt `(push-hval0 ,offset))))
                 (case *value-to-go*
                   ((BX) (wt `(get-lval0 ,offset)))
                   ((PUSH) (wt `(push-lval0 ,offset)))))))
          (else
           (let ((baseoffset *bp*)
                 (level (- *level* (car (var-loc var)))) 
                 (offset (cdr (var-loc var))))
             (if (or (var-assigned var) (var-closed var))
                 (case *value-to-go*
                   ((BX) (wt `(get-hval ,baseoffset ,level ,offset)))
                   ((PUSH) (wt `(push-hval ,baseoffset ,level ,offset))))
                 (case *value-to-go*
                   ((BX) (wt `(get-lval ,baseoffset ,level ,offset)))
                   ((PUSH) (wt `(push-lval ,baseoffset ,level ,offset)))))))))
  (cmp:exit))

(define (c2gvref name)
  (case *value-to-go*
    ((BX) (wt `(get-gval ,name)))
    ((PUSH) (wt `(push-gval ,name))))
  (cmp:exit))

(define (c1set! args)
  (if (or (end? args) (end? (cdr args)) (not (end? (cddr args))))
      (scbad-args 'set! args))
  (let ((name (car args))
        (form (cadr args)))
    (cond ((not (symbol? name))
           (scerror "~s is not a symbol." name))
          ((member name '(if cond case and or begin lambda delay let let* 
                          letrec do set! quote quasiquote define macro))
           (scerror "Cannot set to the keyword ~s." name))
          ((eq? name form)
           (c1vref name))
          (else
            (let lookup ((env *env*) (ccb #f))
              (if (null? env)
                  (list 'set! #;c2gset! name (c1expr form))
                  (let ((var (car env)))
                    (cond ((eq? var 'CB) (lookup (cdr env) #t))
                          ((eq? (var-name var) name)
                           (if ccb (set-var-closed var #t))
                           (set-var-assigned var #t)
                           (list 'set! #;c2set! var ccb (c1expr form)))
                          (else (lookup (cdr env) ccb))))))))))

(define (c2set! var ccb form)
  (c2get-expr* form)
  (cond (ccb (let ((offset (- *cenv-loc* *bp*))
                   (n (- *cenv-length* (var-closed var) 1)))
               (if (zero? *level*)
                   (wt `(set-cval0 ,offset ,n))
                   (wt `(set-cval ,*bp* ,*level* ,offset ,n)))))
        ((= (car (var-loc var)) *level*)
         (wt `(set-hval0 ,(- (cdr (var-loc var)) *bp*))))
        (else (wt `(set-hval ,*bp* ,(- *level* (car (var-loc var)))
                             ,(cdr (var-loc var))))))
  (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
  (cmp:exit))

(define (c2gset! name form)
  (c2get-expr* form)
  (wt `(set-gval ,name))
  (if (eq? *value-to-go* 'PUSH) (wt '(push-bx)))
  (cmp:exit))

(define (end? x)
  (cond ((pair? x) #f)
        ((null? x) #t)
        (else (scerror "~s is not a pair." x))))

(define (c1map fun l)
  (if (end? l)
      '()
      (cons (fun (car l)) (c1map fun (cdr l)))))

(define (scbad-args name args)
  (scerror "~s is bad arguments to ~s." name args))

(define (scbad-binding binding)
  (scerror "~s is bad variable binding." binding))

(define (scerror s . args)     ; Modefied by N.Watanabe
;; for UNIX
;  (error 'compile-error         
;	 'format-string    s
;	 'format-arguments args)
;  (return-to-sctop)
;;
  (format #t "~&Compile error : ")
  (apply format #t s args)
  (format #t "~%")
;; for DOS
  ;
;; for UNIX
  (error-break)
  )

